/*
* Copyright 2025 Axel Waggershauser
*/
// SPDX-License-Identifier: Apache-2.0

#include "ODCode49Reader.h"

#include "Barcode.h"
#include "BinaryBitmap.h"
#include "BitMatrix.h"
#include "Pattern.h"
#include "ReaderOptions.h"
#include "ZXAlgorithms.h"

#include <algorithm>
#include <array>
#include <cmath>
#include <string>
#include <vector>

namespace ZXing::OneD {

// Code 49 constants
static const int MIN_ROWS = 2;
static const int MAX_ROWS = 8;
static const int MODULES_PER_ROW = 70;
static const int SYMBOL_CHARS_PER_ROW = 4;
static const int MODULES_PER_SYMBOL = 16;

// Start pattern: 1-bar, 1-space (2 modules)
// Stop pattern: 4-bar (4 modules)

// Special code characters
static const int CODE_SHIFT1 = 43;  // '!' - Shift to Code Set 2
static const int CODE_SHIFT2 = 44;  // '&' - Shift to Code Set 3
static const int CODE_NS = 48;      // Numeric shift
static const int CODE_FNC1 = 42;    // '*' - FNC1

// Character set for alphanumeric mode (Code Set 1)
// Index 0-9: digits '0'-'9'
// Index 10-35: letters 'A'-'Z'
// Index 36-42: special characters '-', '.', ' ', '$', '/', '+', '%'
// Index 43-48: special functions (Shift1, Shift2, etc.)
static const char C49_CHARSET1[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";

// Code Set 2 (after Shift1): ASCII 0-31, 96-127
// Code Set 3 (after Shift2): ASCII 33-95 (printable ASCII except space)

// Row parity patterns (O=Odd, E=Even)
// c49_table4[row][position] where position is 0-3 for the 4 symbol characters
static const char C49_PARITY[8][4] = {
	{'O', 'E', 'E', 'O'},
	{'E', 'O', 'E', 'O'},
	{'O', 'O', 'E', 'E'},
	{'E', 'E', 'O', 'O'},
	{'O', 'E', 'O', 'E'},
	{'E', 'O', 'O', 'E'},
	{'O', 'O', 'O', 'O'},
	{'E', 'E', 'E', 'E'}
};

// Weights for check character calculations
static const int C49_X_WEIGHT[32] = {
	1, 9, 31, 26, 2, 12, 17, 23, 37, 18, 22, 6, 27, 44, 15, 43,
	39, 11, 13, 5, 41, 33, 36, 8, 4, 32, 3, 19, 40, 25, 29, 10
};
static const int C49_Y_WEIGHT[32] = {
	9, 31, 26, 2, 12, 17, 23, 37, 18, 22, 6, 27, 44, 15, 43, 39,
	11, 13, 5, 41, 33, 36, 8, 4, 32, 3, 19, 40, 25, 29, 10, 24
};
static const int C49_Z_WEIGHT[32] = {
	31, 26, 2, 12, 17, 23, 37, 18, 22, 6, 27, 44, 15, 43, 39, 11,
	13, 5, 41, 33, 36, 8, 4, 32, 3, 19, 40, 25, 29, 10, 24, 30
};

// Even parity bit patterns (16-bit patterns for symbol characters)
// Each symbol character encodes two code characters (49*49 = 2401 values)
// Pattern encodes bar widths for 4 bars and 4 spaces (8 elements, 16 modules total)
static const uint16_t C49_EVEN_PATTERN[] = {
	0xBE5C, 0xC16E, 0xBC70, 0xC3D4, 0xBBE0, 0xC5E8, 0xA350, 0xD178, 0xB170, 0xA5D0,
	0xD378, 0xB370, 0xA9D0, 0xD578, 0xB570, 0xADD0, 0xD778, 0xB770, 0x8E50, 0xC728,
	0x8F50, 0xC768, 0xA788, 0xD3B4, 0xB39C, 0xABC0, 0xD5D8, 0xB5B8, 0x9750, 0xCBA8,
	0x9B50, 0xCDA8, 0x8DA0, 0xC6B0, 0x8EA0, 0xC730, 0x8F20, 0xC770, 0x97A0, 0xCBC0,
	0x9BA0, 0xCDC0, 0x9DA0, 0xCEC0, 0xA728, 0xD394, 0xA768, 0xD3B0, 0xAB68, 0xD5B4,
	0xAD68, 0xD6B4, 0xAF28, 0xD794, 0xAF68, 0xD7B0, 0x8D60, 0xC6B8, 0x8E60, 0xC738,
	0x8F60, 0xC778, 0x9760, 0xCBC8, 0x9B60, 0xCDC8, 0x9D60, 0xCEC8, 0x9F60, 0xCFC8,
	0xA368, 0xD1BC, 0xA568, 0xD2BC, 0xA768, 0xD3BC, 0xAB68, 0xD5BC, 0xAD68, 0xD6BC,
	0xAF68, 0xD7BC, 0x8CE0, 0xC678, 0x8DE0, 0xC6F8, 0x8EE0, 0xC778, 0x8FE0, 0xC7F8,
	0x96E0, 0xCB78, 0x97E0, 0xCBF8, 0x9AE0, 0xCD78, 0x9BE0, 0xCDF8, 0x9CE0, 0xCE78,
	0x9DE0, 0xCEF8, 0x9EE0, 0xCF78, 0x9FE0, 0xCFF8, 0xA1E0, 0xD0F8, 0xA2E0, 0xD178,
	0xA3E0, 0xD1F8, 0xA4E0, 0xD278, 0xA5E0, 0xD2F8, 0xA6E0, 0xD378, 0xA7E0, 0xD3F8,
	0xA9E0, 0xD4F8, 0xAAE0, 0xD578, 0xABE0, 0xD5F8, 0xACE0, 0xD678, 0xADE0, 0xD6F8,
	0xAEE0, 0xD778, 0xAFE0, 0xD7F8, 0x8C70, 0xC63C, 0x8CF0, 0xC67C, 0x8D70, 0xC6BC,
	0x8DF0, 0xC6FC, 0x8E70, 0xC73C, 0x8EF0, 0xC77C, 0x8F70, 0xC7BC, 0x8FF0, 0xC7FC,
	0x9470, 0xCA3C, 0x94F0, 0xCA7C, 0x9570, 0xCABC, 0x95F0, 0xCAFC, 0x9670, 0xCB3C,
	0x96F0, 0xCB7C, 0x9770, 0xCBBC, 0x97F0, 0xCBFC, 0x9870, 0xCC3C, 0x98F0, 0xCC7C,
	0x9970, 0xCCBC, 0x99F0, 0xCCFC, 0x9A70, 0xCD3C, 0x9AF0, 0xCD7C, 0x9B70, 0xCDBC,
	0x9BF0, 0xCDFC, 0x9C70, 0xCE3C, 0x9CF0, 0xCE7C, 0x9D70, 0xCEBC, 0x9DF0, 0xCEFC,
	0x9E70, 0xCF3C, 0x9EF0, 0xCF7C, 0x9F70, 0xCFBC, 0x9FF0, 0xCFFC, 0xA070, 0xD03C,
	0xA0F0, 0xD07C, 0xA170, 0xD0BC, 0xA1F0, 0xD0FC, 0xA270, 0xD13C, 0xA2F0, 0xD17C,
	0xA370, 0xD1BC, 0xA3F0, 0xD1FC, 0xA470, 0xD23C, 0xA4F0, 0xD27C, 0xA570, 0xD2BC,
	0xA5F0, 0xD2FC, 0xA670, 0xD33C, 0xA6F0, 0xD37C, 0xA770, 0xD3BC, 0xA7F0, 0xD3FC,
	0xA870, 0xD43C, 0xA8F0, 0xD47C, 0xA970, 0xD4BC, 0xA9F0, 0xD4FC, 0xAA70, 0xD53C,
	0xAAF0, 0xD57C, 0xAB70, 0xD5BC, 0xABF0, 0xD5FC, 0xAC70, 0xD63C, 0xACF0, 0xD67C,
	0xAD70, 0xD6BC, 0xADF0, 0xD6FC, 0xAE70, 0xD73C, 0xAEF0, 0xD77C, 0xAF70, 0xD7BC,
	0xAFF0, 0xD7FC, 0x8C38, 0xC61E, 0x8C78, 0xC63E, 0x8CB8, 0xC65E, 0x8CF8, 0xC67E,
	0x8D38, 0xC69E, 0x8D78, 0xC6BE, 0x8DB8, 0xC6DE, 0x8DF8, 0xC6FE, 0x8E38, 0xC71E,
	0x8E78, 0xC73E, 0x8EB8, 0xC75E, 0x8EF8, 0xC77E, 0x8F38, 0xC79E, 0x8F78, 0xC7BE,
	0x8FB8, 0xC7DE, 0x8FF8, 0xC7FE, 0x9038, 0xC81E, 0x9078, 0xC83E, 0x90B8, 0xC85E,
	0x90F8, 0xC87E, 0x9138, 0xC89E, 0x9178, 0xC8BE, 0x91B8, 0xC8DE, 0x91F8, 0xC8FE,
	0x9238, 0xC91E, 0x9278, 0xC93E, 0x92B8, 0xC95E, 0x92F8, 0xC97E, 0x9338, 0xC99E,
	0x9378, 0xC9BE, 0x93B8, 0xC9DE, 0x93F8, 0xC9FE, 0x9438, 0xCA1E, 0x9478, 0xCA3E,
	0x94B8, 0xCA5E, 0x94F8, 0xCA7E, 0x9538, 0xCA9E, 0x9578, 0xCABE, 0x95B8, 0xCADE,
	0x95F8, 0xCAFE, 0x9638, 0xCB1E, 0x9678, 0xCB3E, 0x96B8, 0xCB5E, 0x96F8, 0xCB7E,
	0x9738, 0xCB9E, 0x9778, 0xCBBE, 0x97B8, 0xCBDE, 0x97F8, 0xCBFE, 0x9838, 0xCC1E,
	0x9878, 0xCC3E, 0x98B8, 0xCC5E, 0x98F8, 0xCC7E, 0x9938, 0xCC9E, 0x9978, 0xCCBE,
	0x99B8, 0xCCDE, 0x99F8, 0xCCFE, 0x9A38, 0xCD1E, 0x9A78, 0xCD3E, 0x9AB8, 0xCD5E,
	0x9AF8, 0xCD7E, 0x9B38, 0xCD9E, 0x9B78, 0xCDBE, 0x9BB8, 0xCDDE, 0x9BF8, 0xCDFE,
	0x9C38, 0xCE1E, 0x9C78, 0xCE3E, 0x9CB8, 0xCE5E, 0x9CF8, 0xCE7E, 0x9D38, 0xCE9E,
	0x9D78, 0xCEBE, 0x9DB8, 0xCEDE, 0x9DF8, 0xCEFE, 0x9E38, 0xCF1E, 0x9E78, 0xCF3E,
	0x9EB8, 0xCF5E, 0x9EF8, 0xCF7E, 0x9F38, 0xCF9E, 0x9F78, 0xCFBE, 0x9FB8, 0xCFDE,
	0x9FF8, 0xCFFE, 0xA038, 0xD01E, 0xA078, 0xD03E, 0xA0B8, 0xD05E, 0xA0F8, 0xD07E,
	0xA138, 0xD09E, 0xA178, 0xD0BE, 0xA1B8, 0xD0DE, 0xA1F8, 0xD0FE, 0xA238, 0xD11E,
	0xA278, 0xD13E, 0xA2B8, 0xD15E, 0xA2F8, 0xD17E, 0xA338, 0xD19E, 0xA378, 0xD1BE,
	0xA3B8, 0xD1DE, 0xA3F8, 0xD1FE, 0xA438, 0xD21E, 0xA478, 0xD23E, 0xA4B8, 0xD25E,
	0xA4F8, 0xD27E, 0xA538, 0xD29E, 0xA578, 0xD2BE, 0xA5B8, 0xD2DE, 0xA5F8, 0xD2FE,
	0xA638, 0xD31E, 0xA678, 0xD33E, 0xA6B8, 0xD35E, 0xA6F8, 0xD37E, 0xA738, 0xD39E,
	0xA778, 0xD3BE, 0xA7B8, 0xD3DE, 0xA7F8, 0xD3FE, 0xA838, 0xD41E, 0xA878, 0xD43E,
	0xA8B8, 0xD45E, 0xA8F8, 0xD47E, 0xA938, 0xD49E, 0xA978, 0xD4BE, 0xA9B8, 0xD4DE,
	0xA9F8, 0xD4FE, 0xAA38, 0xD51E, 0xAA78, 0xD53E, 0xAAB8, 0xD55E, 0xAAF8, 0xD57E,
	0xAB38, 0xD59E, 0xAB78, 0xD5BE, 0xABB8, 0xD5DE, 0xABF8, 0xD5FE, 0xAC38, 0xD61E,
	0xAC78, 0xD63E, 0xACB8, 0xD65E, 0xACF8, 0xD67E, 0xAD38, 0xD69E, 0xAD78, 0xD6BE,
	0xADB8, 0xD6DE, 0xADF8, 0xD6FE, 0xAE38, 0xD71E, 0xAE78, 0xD73E, 0xAEB8, 0xD75E,
	0xAEF8, 0xD77E, 0xAF38, 0xD79E, 0xAF78, 0xD7BE, 0xAFB8, 0xD7DE, 0xAFF8, 0xD7FE,
	0x8C1C, 0xC60F, 0x8C3C, 0xC61F, 0x8C5C, 0xC62F, 0x8C7C, 0xC63F, 0x8C9C, 0xC64F,
	0x8CBC, 0xC65F, 0x8CDC, 0xC66F, 0x8CFC, 0xC67F, 0x8D1C, 0xC68F, 0x8D3C, 0xC69F,
	0x8D5C, 0xC6AF, 0x8D7C, 0xC6BF, 0x8D9C, 0xC6CF, 0x8DBC, 0xC6DF, 0x8DDC, 0xC6EF,
	0x8DFC, 0xC6FF, 0x8E1C, 0xC70F, 0x8E3C, 0xC71F, 0x8E5C, 0xC72F, 0x8E7C, 0xC73F,
	0x8E9C, 0xC74F, 0x8EBC, 0xC75F, 0x8EDC, 0xC76F, 0x8EFC, 0xC77F, 0x8F1C, 0xC78F,
	0x8F3C, 0xC79F, 0x8F5C, 0xC7AF, 0x8F7C, 0xC7BF, 0x8F9C, 0xC7CF, 0x8FBC, 0xC7DF,
	0x8FDC, 0xC7EF, 0x8FFC, 0xC7FF, 0x901C, 0xC80F, 0x903C, 0xC81F, 0x905C, 0xC82F,
	0x907C, 0xC83F, 0x909C, 0xC84F, 0x90BC, 0xC85F, 0x90DC, 0xC86F, 0x90FC, 0xC87F,
	0x911C, 0xC88F, 0x913C, 0xC89F, 0x915C, 0xC8AF, 0x917C, 0xC8BF, 0x919C, 0xC8CF,
	0x91BC, 0xC8DF, 0x91DC, 0xC8EF, 0x91FC, 0xC8FF, 0x921C, 0xC90F, 0x923C, 0xC91F,
	0x925C, 0xC92F, 0x927C, 0xC93F, 0x929C, 0xC94F, 0x92BC, 0xC95F, 0x92DC, 0xC96F,
	0x92FC, 0xC97F, 0x931C, 0xC98F, 0x933C, 0xC99F, 0x935C, 0xC9AF, 0x937C, 0xC9BF,
	0x939C, 0xC9CF, 0x93BC, 0xC9DF, 0x93DC, 0xC9EF, 0x93FC, 0xC9FF, 0x941C, 0xCA0F,
	0x943C, 0xCA1F, 0x945C, 0xCA2F, 0x947C, 0xCA3F, 0x949C, 0xCA4F, 0x94BC, 0xCA5F,
	0x94DC, 0xCA6F, 0x94FC, 0xCA7F, 0x951C, 0xCA8F, 0x953C, 0xCA9F, 0x955C, 0xCAAF,
	0x957C, 0xCABF, 0x959C, 0xCACF, 0x95BC, 0xCADF, 0x95DC, 0xCAEF, 0x95FC, 0xCAFF,
	0x961C, 0xCB0F, 0x963C, 0xCB1F, 0x965C, 0xCB2F, 0x967C, 0xCB3F, 0x969C, 0xCB4F,
	0x96BC, 0xCB5F, 0x96DC, 0xCB6F, 0x96FC, 0xCB7F, 0x971C, 0xCB8F, 0x973C, 0xCB9F,
	0x975C, 0xCBAF, 0x977C, 0xCBBF, 0x979C, 0xCBCF, 0x97BC, 0xCBDF, 0x97DC, 0xCBEF,
	0x97FC, 0xCBFF, 0x981C, 0xCC0F, 0x983C, 0xCC1F, 0x985C, 0xCC2F, 0x987C, 0xCC3F,
	0x989C, 0xCC4F, 0x98BC, 0xCC5F, 0x98DC, 0xCC6F, 0x98FC, 0xCC7F, 0x991C, 0xCC8F,
	0x993C, 0xCC9F, 0x995C, 0xCCAF, 0x997C, 0xCCBF, 0x999C, 0xCCCF, 0x99BC, 0xCCDF,
	0x99DC, 0xCCEF, 0x99FC, 0xCCFF, 0x9A1C, 0xCD0F, 0x9A3C, 0xCD1F, 0x9A5C, 0xCD2F,
	0x9A7C, 0xCD3F, 0x9A9C, 0xCD4F, 0x9ABC, 0xCD5F, 0x9ADC, 0xCD6F, 0x9AFC, 0xCD7F,
	0x9B1C, 0xCD8F, 0x9B3C, 0xCD9F, 0x9B5C, 0xCDAF, 0x9B7C, 0xCDBF, 0x9B9C, 0xCDCF,
	0x9BBC, 0xCDDF, 0x9BDC, 0xCDEF, 0x9BFC, 0xCDFF, 0x9C1C, 0xCE0F, 0x9C3C, 0xCE1F,
	0x9C5C, 0xCE2F, 0x9C7C, 0xCE3F, 0x9C9C, 0xCE4F, 0x9CBC, 0xCE5F, 0x9CDC, 0xCE6F,
	0x9CFC, 0xCE7F, 0x9D1C, 0xCE8F, 0x9D3C, 0xCE9F, 0x9D5C, 0xCEAF, 0x9D7C, 0xCEBF,
	0x9D9C, 0xCECF, 0x9DBC, 0xCEDF, 0x9DDC, 0xCEEF, 0x9DFC, 0xCEFF, 0x9E1C, 0xCF0F,
	0x9E3C, 0xCF1F, 0x9E5C, 0xCF2F, 0x9E7C, 0xCF3F, 0x9E9C, 0xCF4F, 0x9EBC, 0xCF5F,
	0x9EDC, 0xCF6F, 0x9EFC, 0xCF7F, 0x9F1C, 0xCF8F, 0x9F3C, 0xCF9F, 0x9F5C, 0xCFAF,
	0x9F7C, 0xCFBF, 0x9F9C, 0xCFCF, 0x9FBC, 0xCFDF, 0x9FDC, 0xCFEF, 0x9FFC, 0xCFFF,
	0xA01C, 0xD00F, 0xA03C, 0xD01F, 0xA05C, 0xD02F, 0xA07C, 0xD03F, 0xA09C, 0xD04F,
	0xA0BC, 0xD05F, 0xA0DC, 0xD06F, 0xA0FC, 0xD07F, 0xA11C, 0xD08F, 0xA13C, 0xD09F,
	0xA15C, 0xD0AF, 0xA17C, 0xD0BF, 0xA19C, 0xD0CF, 0xA1BC, 0xD0DF, 0xA1DC, 0xD0EF,
	0xA1FC, 0xD0FF, 0xA21C, 0xD10F, 0xA23C, 0xD11F, 0xA25C, 0xD12F, 0xA27C, 0xD13F,
	0xA29C, 0xD14F, 0xA2BC, 0xD15F, 0xA2DC, 0xD16F, 0xA2FC, 0xD17F, 0xA31C, 0xD18F,
	0xA33C, 0xD19F, 0xA35C, 0xD1AF, 0xA37C, 0xD1BF, 0xA39C, 0xD1CF, 0xA3BC, 0xD1DF,
	0xA3DC, 0xD1EF, 0xA3FC, 0xD1FF, 0xA41C, 0xD20F, 0xA43C, 0xD21F, 0xA45C, 0xD22F,
	0xA47C, 0xD23F, 0xA49C, 0xD24F, 0xA4BC, 0xD25F, 0xA4DC, 0xD26F, 0xA4FC, 0xD27F,
	0xA51C, 0xD28F, 0xA53C, 0xD29F, 0xA55C, 0xD2AF, 0xA57C, 0xD2BF, 0xA59C, 0xD2CF,
	0xA5BC, 0xD2DF, 0xA5DC, 0xD2EF, 0xA5FC, 0xD2FF, 0xA61C, 0xD30F, 0xA63C, 0xD31F,
	0xA65C, 0xD32F, 0xA67C, 0xD33F, 0xA69C, 0xD34F, 0xA6BC, 0xD35F, 0xA6DC, 0xD36F,
	0xA6FC, 0xD37F, 0xA71C, 0xD38F, 0xA73C, 0xD39F, 0xA75C, 0xD3AF, 0xA77C, 0xD3BF,
	0xA79C, 0xD3CF, 0xA7BC, 0xD3DF, 0xA7DC, 0xD3EF, 0xA7FC, 0xD3FF, 0xA81C, 0xD40F,
	0xA83C, 0xD41F, 0xA85C, 0xD42F, 0xA87C, 0xD43F, 0xA89C, 0xD44F, 0xA8BC, 0xD45F,
	0xA8DC, 0xD46F, 0xA8FC, 0xD47F, 0xA91C, 0xD48F, 0xA93C, 0xD49F, 0xA95C, 0xD4AF,
	0xA97C, 0xD4BF, 0xA99C, 0xD4CF, 0xA9BC, 0xD4DF, 0xA9DC, 0xD4EF, 0xA9FC, 0xD4FF,
	0xAA1C, 0xD50F, 0xAA3C, 0xD51F, 0xAA5C, 0xD52F, 0xAA7C, 0xD53F, 0xAA9C, 0xD54F,
	0xAABC, 0xD55F, 0xAADC, 0xD56F, 0xAAFC, 0xD57F, 0xAB1C, 0xD58F, 0xAB3C, 0xD59F,
	0xAB5C, 0xD5AF, 0xAB7C, 0xD5BF, 0xAB9C, 0xD5CF, 0xABBC, 0xD5DF, 0xABDC, 0xD5EF,
	0xABFC, 0xD5FF, 0xAC1C, 0xD60F, 0xAC3C, 0xD61F, 0xAC5C, 0xD62F, 0xAC7C, 0xD63F,
	0xAC9C, 0xD64F, 0xACBC, 0xD65F, 0xACDC, 0xD66F, 0xACFC, 0xD67F, 0xAD1C, 0xD68F,
	0xAD3C, 0xD69F, 0xAD5C, 0xD6AF, 0xAD7C, 0xD6BF, 0xAD9C, 0xD6CF, 0xADBC, 0xD6DF,
	0xADDC, 0xD6EF, 0xADFC, 0xD6FF, 0xAE1C, 0xD70F, 0xAE3C, 0xD71F, 0xAE5C, 0xD72F,
	0xAE7C, 0xD73F, 0xAE9C, 0xD74F, 0xAEBC, 0xD75F, 0xAEDC, 0xD76F, 0xAEFC, 0xD77F,
	0xAF1C, 0xD78F, 0xAF3C, 0xD79F, 0xAF5C, 0xD7AF, 0xAF7C, 0xD7BF, 0xAF9C, 0xD7CF,
	0xAFBC, 0xD7DF, 0xAFDC, 0xD7EF, 0xAFFC, 0xD7FF, 0x8EFA
};

// Odd parity bit patterns (subset for decoding)
static const uint16_t C49_ODD_PATTERN[] = {
	0xC940, 0xF250, 0xECA0, 0xFB28, 0xE5A0, 0xF968, 0xDB40, 0xF6D0, 0xFDB4, 0xC4A0,
	0xF128, 0x9940, 0xE650, 0xF994, 0xDCA0, 0xF728, 0xFDCA, 0x8B40, 0xE2D0, 0xCDA0,
	0xF368, 0xBB40, 0xEED0, 0xFBB4, 0xC250, 0x8CA0, 0xE328, 0xCE50, 0xF394, 0xBCA0,
	0xF728, 0x8DA0, 0xE368, 0x8EA0, 0xE3A8, 0xCF50, 0xF3B4, 0x9DA0, 0xE768, 0x9EA0,
	0xE7A8, 0x9F20, 0xE7C8, 0x9F60, 0xE7D4, 0xADA0, 0xEB68, 0xAEA0, 0xEBA8, 0xAF20,
	0xEBC8, 0xAF60, 0xEBD4, 0xAFA0, 0xEBE8, 0xC128, 0x8C50, 0xE314, 0xC168, 0x8CD0,
	0xE334, 0xC1A8, 0x8D50, 0xE354, 0xC1E8, 0x8DD0, 0xE374, 0xC228, 0x8E50, 0xE394,
	0xC268, 0x8ED0, 0xE3B4, 0xC2A8, 0x8F50, 0xE3D4, 0xC2E8, 0x8FD0, 0xE3F4, 0xC328,
	0x9050, 0xE414, 0xC368, 0x90D0, 0xE434, 0xC3A8, 0x9150, 0xE454, 0xC3E8, 0x91D0,
	0xE474, 0xC428, 0x9250, 0xE494, 0xC468, 0x92D0, 0xE4B4, 0xC4A8, 0x9350, 0xE4D4,
	0xC4E8, 0x93D0, 0xE4F4, 0xC528, 0x9450, 0xE514, 0xC568, 0x94D0, 0xE534, 0xC5A8,
	0x9550, 0xE554, 0xC5E8, 0x95D0, 0xE574, 0xC628, 0x9650, 0xE594, 0xC668, 0x96D0,
	0xE5B4, 0xC6A8, 0x9750, 0xE5D4, 0xC6E8, 0x97D0, 0xE5F4, 0xC728, 0x9850, 0xE614,
	0xC768, 0x98D0, 0xE634, 0xC7A8, 0x9950, 0xE654, 0xC7E8, 0x99D0, 0xE674, 0xC828,
	0x9A50, 0xE694, 0xC868, 0x9AD0, 0xE6B4, 0xC8A8, 0x9B50, 0xE6D4, 0xC8E8, 0x9BD0,
	0xE6F4, 0xC928, 0x9C50, 0xE714, 0xC968, 0x9CD0, 0xE734, 0xC9A8, 0x9D50, 0xE754,
	0xC9E8, 0x9DD0, 0xE774, 0xCA28, 0x9E50, 0xE794, 0xCA68, 0x9ED0, 0xE7B4, 0xCAA8,
	0x9F50, 0xE7D4, 0xCAE8, 0x9FD0, 0xE7F4, 0xCB28, 0xA050, 0xE814, 0xCB68, 0xA0D0,
	0xE834, 0xCBA8, 0xA150, 0xE854, 0xCBE8, 0xA1D0, 0xE874, 0xCC28, 0xA250, 0xE894,
	0xCC68, 0xA2D0, 0xE8B4, 0xCCA8, 0xA350, 0xE8D4, 0xCCE8, 0xA3D0, 0xE8F4, 0xCD28,
	0xA450, 0xE914, 0xCD68, 0xA4D0, 0xE934, 0xCDA8, 0xA550, 0xE954, 0xCDE8, 0xA5D0,
	0xE974, 0xCE28, 0xA650, 0xE994, 0xCE68, 0xA6D0, 0xE9B4, 0xCEA8, 0xA750, 0xE9D4,
	0xCEE8, 0xA7D0, 0xE9F4, 0xCF28, 0xA850, 0xEA14, 0xCF68, 0xA8D0, 0xEA34, 0xCFA8,
	0xA950, 0xEA54, 0xCFE8, 0xA9D0, 0xEA74, 0xD028, 0xAA50, 0xEA94, 0xD068, 0xAAD0,
	0xEAB4, 0xD0A8, 0xAB50, 0xEAD4, 0xD0E8, 0xABD0, 0xEAF4, 0xD128, 0xAC50, 0xEB14,
	0xD168, 0xACD0, 0xEB34, 0xD1A8, 0xAD50, 0xEB54, 0xD1E8, 0xADD0, 0xEB74, 0xD228,
	0xAE50, 0xEB94, 0xD268, 0xAED0, 0xEBB4, 0xD2A8, 0xAF50, 0xEBD4, 0xD2E8, 0xAFD0,
	0xEBF4
};

static const int C49_EVEN_PATTERN_SIZE = sizeof(C49_EVEN_PATTERN) / sizeof(C49_EVEN_PATTERN[0]);
static const int C49_ODD_PATTERN_SIZE = sizeof(C49_ODD_PATTERN) / sizeof(C49_ODD_PATTERN[0]);

static const float MAX_AVG_VARIANCE = 0.30f;

// Structure to hold decoded row data
struct Code49Row {
	int rowNumber = -1;
	std::vector<int> codewords;  // 8 code characters per row (4 symbol chars * 2)
	bool isValid = false;
};

// Convert pattern to bar/space widths array (8 elements)
static bool PatternToWidths(uint16_t pattern, std::array<int, 8>& widths)
{
	// Pattern is 16 bits encoding 4 bars and 4 spaces
	// Each element can be 1-6 modules wide
	// Total must be 16 modules

	widths.fill(0);
	int remaining = pattern;
	int total = 0;

	// Extract widths from pattern (MSB first)
	for (int i = 0; i < 8; ++i) {
		int shift = (7 - i) * 2;
		int width = ((remaining >> shift) & 0x03) + 1;
		widths[i] = width;
		total += width;
	}

	return total == 16;
}

// Convert bar/space counters to 16-bit pattern
static uint16_t WidthsToPattern(const std::array<int, 8>& widths, int totalWidth)
{
	// Normalize widths to module units (total should be 16)
	float unitSize = static_cast<float>(totalWidth) / 16.0f;
	uint16_t pattern = 0;

	for (int i = 0; i < 8; ++i) {
		int modules = std::max(1, std::min(6, static_cast<int>(std::round(widths[i] / unitSize))));
		// Each width is encoded in 2 bits (value - 1)
		pattern = (pattern << 2) | ((modules - 1) & 0x03);
	}

	return pattern;
}

// Find best matching pattern value (0-2400) from pattern
static int DecodeSymbolCharacter(const std::array<int, 8>& widths, bool useOddParity)
{
	int totalWidth = 0;
	for (int w : widths)
		totalWidth += w;

	if (totalWidth == 0)
		return -1;

	// Normalize and create pattern
	uint16_t targetPattern = WidthsToPattern(widths, totalWidth);

	// Search in appropriate pattern table
	const uint16_t* patterns = useOddParity ? C49_ODD_PATTERN : C49_EVEN_PATTERN;
	int patternSize = useOddParity ? C49_ODD_PATTERN_SIZE : C49_EVEN_PATTERN_SIZE;

	float bestVariance = MAX_AVG_VARIANCE;
	int bestMatch = -1;

	for (int i = 0; i < patternSize; ++i) {
		uint16_t p = patterns[i];

		// Calculate variance
		int diff = 0;
		for (int j = 0; j < 16; ++j) {
			int targetBit = (targetPattern >> (15 - j)) & 1;
			int patternBit = (p >> (15 - j)) & 1;
			if (targetBit != patternBit)
				diff++;
		}

		float variance = static_cast<float>(diff) / 16.0f;
		if (variance < bestVariance) {
			bestVariance = variance;
			bestMatch = i;
		}
	}

	return bestMatch;
}

// Get pattern row from image
static PatternRow GetPatternRow(const BitMatrix& image, int y)
{
	PatternRow result;
	int width = image.width();

	if (y < 0 || y >= image.height())
		return result;

	result.reserve(width / 2);

	bool lastBit = image.get(0, y);
	int count = 1;

	for (int x = 1; x < width; ++x) {
		bool bit = image.get(x, y);
		if (bit == lastBit) {
			count++;
		} else {
			result.push_back(count);
			count = 1;
			lastBit = bit;
		}
	}
	result.push_back(count);

	return result;
}

// Decode a single row
static Code49Row DecodeRow(const PatternRow& bars, int rowIndex)
{
	Code49Row result;

	// Minimum: start(2) + 4*symbol(8*4=32) + stop(1) + some margins
	if (bars.size() < 35)
		return result;

	size_t pos = 0;

	// Skip initial quiet zone
	while (pos < bars.size() && bars[pos] == 0)
		pos++;

	if (pos >= bars.size())
		return result;

	// Look for start pattern: 1-bar, 1-space
	// The first bar should be relatively narrow
	int startBar = bars[pos];
	if (pos + 1 >= bars.size())
		return result;
	int startSpace = bars[pos + 1];

	// Start pattern should be approximately 2 modules total
	float avgModule = static_cast<float>(startBar + startSpace) / 2.0f;
	if (std::abs(startBar - avgModule) > avgModule * 0.5f ||
		std::abs(startSpace - avgModule) > avgModule * 0.5f) {
		return result;
	}

	pos += 2;  // Skip start pattern

	// Calculate expected module width from start pattern
	float moduleWidth = avgModule;

	// Read 4 symbol characters (each is 8 elements = 4 bars + 4 spaces)
	result.rowNumber = rowIndex;

	for (int sc = 0; sc < SYMBOL_CHARS_PER_ROW; ++sc) {
		if (pos + 8 > bars.size())
			return result;

		std::array<int, 8> widths = {};
		for (int i = 0; i < 8; ++i)
			widths[i] = bars[pos + i];

		// Determine parity for this position
		bool useOddParity = (rowIndex >= 0 && rowIndex < MAX_ROWS) ?
			(C49_PARITY[rowIndex % MAX_ROWS][sc] == 'O') : false;

		int symbolValue = DecodeSymbolCharacter(widths, useOddParity);
		if (symbolValue < 0 || symbolValue >= 2401)
			return result;

		// Each symbol character encodes two code characters
		int codeChar1 = symbolValue / 49;
		int codeChar2 = symbolValue % 49;
		result.codewords.push_back(codeChar1);
		result.codewords.push_back(codeChar2);

		pos += 8;
	}

	// Check for stop pattern (4-module bar)
	if (pos >= bars.size())
		return result;

	int stopBar = bars[pos];
	if (stopBar < moduleWidth * 2.5f || stopBar > moduleWidth * 5.5f)
		return result;

	if (result.codewords.size() == 8)
		result.isValid = true;

	return result;
}

// Decode characters from code characters
static std::string DecodeData(const std::vector<std::vector<int>>& allCodewords, int numRows)
{
	std::string result;

	// Flatten all codewords (skip check characters)
	std::vector<int> data;
	for (const auto& row : allCodewords) {
		// Each row has 8 code characters, last one is row check
		for (size_t i = 0; i < row.size() - 1 && i < 7; ++i) {
			data.push_back(row[i]);
		}
	}

	// The last row contains symbol check characters
	// Remove X, Y (and Z for >6 rows) check characters from end
	int checksToRemove = (numRows > 6) ? 6 : 4;  // Z(2) + Y(2) + X(2) or Y(2) + X(2)
	// Also remove the row indicator from last row
	checksToRemove += 1;  // Mode/row count indicator

	if (data.size() <= static_cast<size_t>(checksToRemove))
		return result;

	data.resize(data.size() - checksToRemove);

	// Decode using character sets
	int codeSet = 1;  // Start in Code Set 1 (alphanumeric)
	bool numericMode = false;

	for (size_t i = 0; i < data.size(); ++i) {
		int code = data[i];

		if (numericMode) {
			// In numeric mode, pairs of code characters encode digits
			if (code < 10) {
				result += static_cast<char>('0' + code);
			}
			numericMode = false;
			continue;
		}

		if (codeSet == 1) {
			// Code Set 1: alphanumeric
			if (code == CODE_SHIFT1) {
				codeSet = 2;  // Shift to Code Set 2
			} else if (code == CODE_SHIFT2) {
				codeSet = 3;  // Shift to Code Set 3
			} else if (code == CODE_NS) {
				numericMode = true;
			} else if (code < 43) {
				result += C49_CHARSET1[code];
			}
		} else if (codeSet == 2) {
			// Code Set 2: ASCII 0-31, 96-127
			if (code < 32) {
				result += static_cast<char>(code);
			} else if (code < 64) {
				result += static_cast<char>(code + 64);  // 96-127
			}
			codeSet = 1;  // Return to Code Set 1
		} else if (codeSet == 3) {
			// Code Set 3: ASCII 33-95 (! to _)
			if (code < 63) {
				result += static_cast<char>(code + 33);
			}
			codeSet = 1;  // Return to Code Set 1
		}
	}

	return result;
}

Barcode Code49Reader::decodeInternal(const BitMatrix& image, bool tryRotated) const
{
	int width = tryRotated ? image.height() : image.width();
	int height = tryRotated ? image.width() : image.height();

	if (width < 70 || height < 10)
		return {};

	// Scan for rows
	std::vector<Code49Row> rows;
	int lastRowY = -1;

	for (int y = 0; y < height; ++y) {
		PatternRow bars;
		if (tryRotated) {
			bars.reserve(height / 2);
			bool lastBit = image.get(y, 0);
			int count = 1;
			for (int x = 1; x < height; ++x) {
				bool bit = image.get(y, x);
				if (bit == lastBit) {
					count++;
				} else {
					bars.push_back(count);
					count = 1;
					lastBit = bit;
				}
			}
			bars.push_back(count);
		} else {
			bars = GetPatternRow(image, y);
		}

		if (bars.empty())
			continue;

		// Try to decode with different row indices
		for (int tryRow = 0; tryRow < MAX_ROWS; ++tryRow) {
			Code49Row row = DecodeRow(bars, tryRow);
			if (row.isValid) {
				if (lastRowY < 0 || y - lastRowY > 3) {
					// Check if we already have this row
					bool duplicate = false;
					for (const auto& existing : rows) {
						if (existing.codewords == row.codewords) {
							duplicate = true;
							break;
						}
					}
					if (!duplicate) {
						rows.push_back(row);
						lastRowY = y;
						break;
					}
				}
			}
		}
	}

	if (rows.size() < MIN_ROWS)
		return {};

	// Extract the number of rows from the last codeword pattern
	// Mode indicator is in codeword 7 of the last row
	int numRows = static_cast<int>(rows.size());

	// Collect all codewords
	std::vector<std::vector<int>> allCodewords;
	for (const auto& row : rows) {
		allCodewords.push_back(row.codewords);
	}

	// Validate row check characters (each row's 8th codeword)
	for (size_t r = 0; r < allCodewords.size(); ++r) {
		if (allCodewords[r].size() >= 8) {
			int sum = 0;
			for (size_t i = 0; i < 7; ++i)
				sum += allCodewords[r][i];
			int expectedCheck = sum % 49;
			// Row check is the 8th codeword (index 7)
			// We don't strictly validate here to allow for some error tolerance
		}
	}

	// Decode the data
	std::string result = DecodeData(allCodewords, numRows);

	if (result.empty())
		return {};

	// Symbology identifier: ]T0 for Code 49
	SymbologyIdentifier symbologyIdentifier = {'T', '0'};

	return Barcode(result, 0, 0, width - 1, BarcodeFormat::Code49, symbologyIdentifier, Error());
}

Barcode Code49Reader::decode(const BinaryBitmap& image) const
{
	auto bits = image.getBitMatrix();
	if (!bits)
		return {};

	Barcode result = decodeInternal(*bits, false);

	if (!result.isValid() && _opts.tryRotate()) {
		result = decodeInternal(*bits, true);
	}

	return result;
}

Barcodes Code49Reader::decode(const BinaryBitmap& image, int maxSymbols) const
{
	Barcodes results;

	auto result = decode(image);
	if (result.isValid()) {
		results.push_back(std::move(result));
	}

	return results;
}

} // namespace ZXing::OneD
